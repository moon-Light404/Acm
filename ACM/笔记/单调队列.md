## 单调队列

单调队列是维护一个单调递增或递减的队列

入队和出队操作满足以下两点：

1、入队：对于一个点而言，如果加入队列后满足队列的单调性质，就可以入队

2、出队：对于一个点而言,如果说新加入的点,比它更加具有潜力,潜力一般指(拓展性更强,生存能力更高,节点入队时间短

单调队列适用于那些范围

单调队列,其实是单调栈的一个升级plus版本,或者说是具有[l,r]区间性质的单调栈.(注:单调栈一般来说是[0,r]类型的)



单调队列算法步骤
对于一个数而言,它可以从队尾入队,必须满足题目的特定条件
对于一个队头的数而言,如果说新来的数,不仅是新来的具有潜力,而且又自身价值还比它价值高,那么不用说队头出队.
总而言之,队列的单调条件,性质如何设置,是我们解题的关键.



***\**\*单调队列的\*\*\*\*核心\*\*\*\*（我认为的哈）：==得到当前的某个范围内的最小值或最大值==

---

==题目==

题目描述
有一个序列a[1],a[2],......,a[n],求其中长度<=m的最大连续子序列和.



题解：可以使用前缀和来求解，`a[i]+a[i+1]+...+a[j]`可以表示为`s[j]- s[i-1]`

我们可以枚举每 m 段数据的右端点，并在左边`1<= i-j <= m`维护左端点，即找出最小的`s[j]`，使得队头的元素永远是最小值。每次只要取队头的`ql`就是当前队列的最小值

用`q数组`保存==前缀和数组的下标==

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+10;
typedef long long ll;
int n,m,q[N],ql,qr;
ll s[N];
int main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++) {
        cin>>s[i];
        s[i]+=s[i-1];
    }
    ll res=INT_MIN;
    // q数组存储下标
    ql=qr=1; // 先把0入队表示s[0]，那么 ql = 1
    q[1]=0;//初始决策
    for (int i=1;i<=n;i++) {
        while(ql<=qr&&i-q[ql]>m) ql++; // 限定范围，超过范围则前面的数要出队
        res=max(res,s[i]-s[q[ql]]);
        // 更新队头，要保持单调的性质
        while(ql<=qr&&s[q[qr]]>=s[i]) qr--; // 新加入的数比前面的小，那么前面的数要出队空出位置给新加入的数
        qr++;
        q[qr]=i;
    }
    cout<<res<<endl;
    return 0;
}
```

详情也可看这篇文章：

https://blog.csdn.net/LJD201724114126/article/details/80663855

