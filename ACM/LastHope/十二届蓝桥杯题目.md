
![img](https://cdn.jsdelivr.net/gh/moon-Light404/my-picGo@master/img/202111262044213.png)

每个点都可以相链接，我们可以求出每两个点所代表的直线表达式，加入到set中进行判重，注意重载运算符。

```c++
#include <iostream>
#include <set>
#include <cmath>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
PII p[1000];
struct line {
	int a, b, c; // 直线的系数
	bool operator <(const line &p) const {
		if (a == p.a)
			return b == p.b ? c < p.c : b < p.b;
		return a < p.a;
	}
	bool operator ==(const line &p) const {
		return a == p.a && b == p.b && c == p.c;
	}
};
int cnt;

set<line> se; // 存储直线去重
int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

int gcdd(int a, int b, int c) {
	return gcd(gcd(a, b), c);
}

int main() {
	int n = 20, m = 21;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++) {
			p[++cnt] = {i, j}; // 记录每个点
		}
	for (int i = 1; i <= cnt; i++)
		for (int j = i + 1; j <= cnt; j++) {
			int a = p[i].y - p[j].y;
			int b = p[j].x - p[i].x;
			int c = p[i].y * (p[i].x - p[j].x) + p[i].x * (p[j].y - p[i].y);
			int t = gcdd(fabs(a), fabs(b), fabs(c));
			se.insert({a / t, b / t, c / t});
		}
	cout << se.size();
	return 0;
}
```





货物摆放

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/moon-Light404/my-picGo@master/img/202111271000509.png)

https://blog.csdn.net/qq_45856614/article/details/115827861

- 递归搜索解法

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef unsigned long long uLL;
const int inf=0x3f3f3f3f;
const int maxn=5e6+5;
const int N=1e7+15;
const LL mod=998244353;
const double pi=acos(-1);
struct node{
    int a,b,c;
    node(int aa,int bb,int cc) { a=aa,b=bb,c=cc; }
    friend bool operator < (node x,node y){
        if(x.a==y.a)
        {
            if(x.b==y.b)
                return x.c<y.c;
            return x.b<y.b;
        }
        return x.a<y.a;
    }
};
set<node>s;
LL n,x[5];
int cnt,prime[maxn],res;
bool is_prime[N],f[maxn];
vector<LL>mid;
void __prime()
{
    for(int i=1;i<=N-5;i++) is_prime[i]=1; is_prime[1]=0;
    for(int i=2;i<=N-5;i++)
        if(is_prime[i])
        {
            prime[++cnt]=i;
            for(int j=i;j<=N-5;j+=i) is_prime[j]=0;
        }
}
/*
2021041820210418
2 3 3 3 17 131 2857 5882353
*/
// 求质因数(可重复，所y数相乘等于原数)
void fen(){
    LL now=n;
    for(int i=1;i<=cnt;i++)
        while(n%prime[i]==0)
            n/=prime[i],mid.push_back(1LL*prime[i]);
}
// 主要函数
void dfs(int ff,int now,LL mul)
{

    if(now==mid.size()) // 把所有因数选完了(一轮)
    {
        x[ff]=mul; // 记录此次选数的乘积
        if(ff==1) // 如果此次已经选完了两轮
        {
            x[2]=n/x[1]/x[0]; // 直接求出第三个数
            if(s.find(node(x[0],x[1],x[2]))!=s.end()) return;
            s.insert(node(x[0],x[1],x[2]));
            res++; // 在集合中对这对数字(3个)去重
        }
        else dfs(ff+1,0,1); // 遍历下一个乘数
        // 0表示从第一个数开始选，此时第一轮的数字已经选过，被第一轮选的时候标记了
        return;
    }
    if(f[now]==0)
    {
        f[now]=1; // 选这个位置上的数字，标记
        dfs(ff,now+1,mul*mid[now]);
        f[now]=0;// 恢复去除标记
        dfs(ff,now+1,mul); // 不选，f[now]默认0
    }
    else dfs(ff,now+1,mul); // f[now]=1,这个数已经被前一轮选过了
}
int main()
{
    __prime();
    scanf("%lld",&n);
    fen();
    for(int i=0;i<mid.size();i++) printf("%d ",mid[i]); printf("\n");
    dfs(0,0,1); 
    // 轮数、因数的位置、乘积(要选3个)
    printf("%d\n",res);
    return 0;
}

```



- 直接遍历求约数数量

```c++
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long LL;
LL yue[101000], cnt;

int main() {
	LL n = 2021041820210418;
	for (LL i = 1; i <= n / i; i++) { // 求所有的约数
		if (n % i == 0) {
			yue[++cnt] = i;
			if (i * i != n)
				yue[++cnt] = n / i; // 把另一个约数也记录下来
		}
	}
	sort(yue + 1, yue + cnt + 1); // 排序
	for (int i = 1; i <= cnt; i++)
		cout << yue[i] << endl;
	cout << cnt << endl;
	int ans = 0;
	for (int i = 1; i <= cnt; i++) {
		for (int j = 1; j <= cnt; j++) {
			if (n % (yue[i]*yue[j]) == 0)
				ans++;
		}
	}
	cout << ans;
	return 0;
}
```





砝码称重

![image-20211127112013520](https://cdn.jsdelivr.net/gh/moon-Light404/my-picGo@master/img/202111271120627.png)

![image-20211127112026530](https://cdn.jsdelivr.net/gh/moon-Light404/my-picGo@master/img/202111271120609.png)

```c++
#include <iostream>
#include <cmath>
using namespace std;
// dp[i][j]表示前i种砝码是否可以称出j重量来 t or f
const int M = 100005;
bool dp[106][M];

int a[M]; // 每个砝码的重量
int main() {
	int N, sum = 0;
	cin >> N;
	for (int i = 1; i <= N; i++) {
		cin >> a[i];
		sum += a[i];
	}
	for (int i = 1; i <= N; i++) { // 前i个砝码
		for (int j = 1; j <= sum; j++) { // 1~sum的重量
			dp[i][j] = dp[i - 1][j];
			if (!dp[i][j]) {
				if (a[i] == j)
					dp[i][j] = true;
				if (dp[i - 1][j + a[i]])
					// 上一个状态可以称出比j大a[i]的重量，这个状态只要把a[i]放在不同侧就可以称出j重量
					dp[i][j] = true;
				if (dp[i - 1][abs(j - a[i])])
					// 上一状态可以称出比j小a[i]的重量,这此只要把a[i]放在同侧就可以称出j重量
//				j = 10, a[i] = 6, dp[i-1][4] = 1,可以放6即可称出10,设左边比右边重4(+4),左边再加6就是(+10)
//				j = 6, a[i] = 10,dp[i-1][4] = 1,上一个状态可以称出4(-4),设左边比右边轻4(-4),左边加上10后就是+6
					dp[i][j] = true;
			}
		}
	}
	long long ans = 0;
	for (int k = 1; k <= sum; k++) { // 遍历总重量,前N个砝码可以称到的重量
		if (dp[N][k])
			ans++;
	}
	cout << ans << endl;

	return 0;
}
```

`dp[i][n]`表示前 i 个砝码是否能够称出重量 n
