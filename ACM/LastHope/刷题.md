#### <a href="https://www.acwing.com/activity/content/problem/content/5900/">括号序列</a>

<mark>栈</mark>  

给定一个括号字符串，求其中最长的合法括号序列长度和数量。

括号序列的性质：

- <u>右括号不能比左括号多(右< 左)，不然右边无法与其进行匹配</u>

![image-20211219121305967](https://cdn.jsdelivr.net/gh/moon-Light404/my-picGo@master/img/202112191213394.png)

- ')' 只能与左边的的'(' 匹配，如果在字符串中间单独出现一个')'，那么两边的字符串就没有联系
- '('与右边的 ')' 进行匹配，遇到 ')' 就将 '(' 出栈

- 栈中存放的是括号序列括号对应的下标值，用于更新最大长度

```c++
#include<iostream>
#include<stack>
using namespace std;
const int N = 1000010;
char s[N];
stack<int> stk; // 存放序列括号对应的下标
int main() {
    scanf("%s", s);
    int resl = 0, resc = 1; // 合法序列的长度和数量
    
    for(int i = 0; s[i]; i++) {
        if(stk.size() && s[i] == ')' && s[stk.top()] == '(') stk.pop();
        else    stk.push(i);
        int r;
        // 不空说明左边有没用的右括号 ')'
        if(stk.size())  r = i - stk.top();
        else    r = i + 1;
        
        if(r > resl)    resl = r, resc = 1; // 更新最长的长度，且数量为1
        else if(r > 0 && r == resl)  resc += 1;
    }
    cout << resl << " " << resc << endl;
    return 0;
}
```

---

#### 括号生成

数字n代表生成括号的对数，设计一个函数，用于生成所有可能的有效的括号组合



方法一：**暴力枚举**，枚举所有'(' 和 ')'的情况，判断结果是否是合法括号对

```c++
实例：
n = 3
((())), (()()),(())(),()(()),()()()

// 判断括号序列是否合法
bool valid(const string& str) {
    int balance = 0;
    for(char c : str) {
     	if(c == '(')	++balance;
        else	--balance;
        if(balance < 0)	return false; // 右括号多了，无法匹配
    }
    return balance == 0;
}

void generate_all(string cur, int n, vector<string> &result) {
	// 递归终点
	if (cur.size() == n) {
		if (valid(cur))
			result.push_back(cur);
		return;
	}
	cur += '(';
	generate_all(cur, n, result);
	cur.pop_back();
	cur += ')';
	generate_all(cur, n, result);
	cur.pop_back();
}

int main() {
	int n;
	vector<string> res;
	string cur;
	cin >> n;
	generate_all(cur, n * 2, res);
	for (string a : res)
		cout << a << ",";
	return 0;
}
```



方法二：添加括号

情况1：剩余的左右括号数量相等，下一个只能用左括号

情况2：剩余左括号<右括号时，说明 '(' 加的比较多，这时可以加'(' 或者 ')'.

```c++
vector<string> res; // 最终的所有括号序列j
void getParenthesis(string str, int left, int right) { // left和right表示还剩下几个括号没填
    if(left == 0 && right == 0) { // 括号都填完了
        res.push_back(str);
        return;
    }
    if(left == right)	getParenthesis(str+'(', left - 1, right);
    else if(left < right) {
        if(left > 0)	getParenthesis(str+'(', left - 1, right);
        getParenthesis(str+")", left, right-1);
    }
}
```







#### 动态规划

印章

![image-20220121005538896](https://cdn.jsdelivr.net/gh/moon-Light404/my-picGo@master/img/202201210055034.png)



```c++
#include <iostream>
#include <cmath>
using namespace std;
const int N = 25;
double dp[N][N];
int n, m;
int main() {
	cin >> n >> m;
	double p = 1.0 / n;
	for (int i = 1; i <= m; i++)
		for (int j = 1; j <= n; j++) {
			if (i < j)
				dp[i][j] = 0;
			if (j == 1)
				dp[i][j] = pow(p, i - 1);
			else
				dp[i][j] = dp[i - 1][j] * (j * 1.0 / n) + dp[i - 1][j - 1] * (n - (j - 1)) * 1.0 / n;
		}
	printf("%.4lf", dp[m][n]);

	return 0;
}
```





#### 分割等和子集

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

思路：转化为01背包问题，因为这个数组可以分成两个和相等的子集，那么这个数组的总和要是偶数，不是偶数直接输入false

状态转化：`dp[i][j]`表示 前 i 个数中是否选出若干个数可以凑成和 j

状态： true || false

`dp[0][0] = false`  初始状态

`dp[i][j] = dp[i-1][j]`

当`nums[i] == j`时，`dp[i][j]=true`

当`num[i] < j`时,`dp[i][j] = dp[i - 1][j-nums[i]]`

**c++题解**

```c++
#include <iostream>
#include <cstring>
using namespace std;
const int N = 210;
int a[N], n, sum;
bool dp[N][N];
int main() {
	dp[0][0] = false;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
		sum += a[i];
	}
	if (sum & 1 == 1) { // 和为奇数不符合题意
		cout << "false";
		return 0;
	}
	int target = sum / 2; // 计算数组和的一半
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= target; j++) {
			dp[i][j] = dp[i - 1][j];

			if (a[i] == j) {
				dp[i][j] = true;
				continue;
			}

			if (a[i] < j)
				dp[i][j] = dp[i - 1][j] || dp[i - 1][j - a[i]];
		}
	}

	cout << dp[n][target];
	return 0;
}
```







#### <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a>

<a href="https://www.acwing.com/solution/content/86234/">**题解**</a>

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

思路：遍历字符串的长度和下标，从左到右遍历字符串

状态转移：`dp[i][j]` 表示 i ~j 的字符串是否是回文子串(true or false)，然后遍历所有dp为true 的数组同时更新最大长度和begin 和回文子串长度

`substr(begin, len)`表示从begin下标截取len长度的字符串。



```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.length();
        if(n < 2)   return s;
        int maxlen = 1, begin = 0; // 最大长度从1开始，若最长的回文子串没用超过2的，那么默认第一个字符
        vector<vector<bool>> dp(n, vector<bool>(n, false));
        for(int i = 0; i < n;i++)   dp[i][i] = true; // 单个字符为回文串
        for(int L = 2; L <= n; L++) { // 长度
            for(int i = 0 ;i < n;i++) { // 下标
                int j = i + L - 1; // 右端点
                if(j >= n)  break;

                if(s[i] != s[j])    dp[i][j] = false;
                else {
                    if(j - i <= 2)  dp[i][j] = true;
                    else    dp[i][j] = dp[i+1][j-1];
                }
                if(dp[i][j] && j - i + 1 > maxlen) {
                    maxlen = j - i + 1;
                    begin = i; // 记录起点
            }
            }
        }
        return s.substr(begin, maxlen);
    }
};
```





#### 无重复字符的最长字串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

<mark>滑动窗口</mark>

```c++
#include <bits/stdc++.h>
using namespace std;

int getLen(string s) {
	int n = s.length();
	if (n <= 1)
		return n;
	unordered_set<char> loop;
	int maxl = 0;
	int left = 0; // 滑动窗口的左端点
	for (int i = 0; i < n; i++) {
		while (loop.find(s[i]) != loop.end()) { // 有重复的数字向右边移动
			loop.erase(s[left]);
			left++;
		}
		maxl = max(maxl, i - left + 1);
		loop.insert(s[i]);
	}
	return maxl;
}

int main() {
	string ss;
	cin >> ss;
	cout << getLen(ss);
	return 0;
}

```



---

#### 验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

- 节点的左子树只包含小于当前的数
- 节点的右子树只包含大于当前的数
- 所有左子树和右子树自身必须是二叉搜索树

**二叉搜索树的性质：** 按照中序遍历得到的序列是递增的

C++代码

```c++
class Solution {
    long pre = LONG_MIN;
public:
    bool isValidBST(TreeNode* root) {
        if(root == NULL)    return true;
        if(!isValidBST(root->left))  return false;
        if(root->val <= pre) return false;

        pre = root->val;
        return isValidBST(root->right);
    }
};
```



#### **<a href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a>**

![image-20220122231313374](https://cdn.jsdelivr.net/gh/moon-Light404/my-picGo@master/img/202201222313493.png)

```c++
class Solution {
public:
    bool isSameTree(TreeNode* ll, TreeNode* rr) {
        if(ll == NULL && rr == NULL)    return true;
        if(ll == NULL || rr == NULL)    return false;
        if(ll->val != rr->val)  return false;
        return  isSameTree(ll->left, rr->right) && isSameTree(ll->right, rr->left);
        // 要保持对称，所以一个left，一个right
    }
    // 比较左右子树是否相等
    bool isSymmetric(TreeNode* root) {
        if(root == NULL)    return true;
        else    return isSameTree(root->left, root->right);
    }
};
```

----





#### <a href = "https://leetcode-cn.com/problems/path-sum/">路径总和</a>

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

**解法一**：BFS

1、可以避免dfs重复遍历多条路的缺点，遍历每一个结点，并保存从根节点到这个点的路径上的树的总和

2、用两个队列，一个用来保存数据val， 一个用来保存结点node

3、当遍历到根节点时，看当前`sum ==? targetSum`

```c++
class Solution {
public:

    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return false;
        queue<TreeNode *> que_node; // 存储遍历的结点
        queue<int> que_val; // 存储遍历的值
        
        que_node.push(root);
        que_val.push(root->val);
        // BFS开始
        while(!que_node.empty()) {
            TreeNode* now = que_node.front();
            int temp = que_val.front(); // 到当前结点的路径上的树的总和
            que_node.pop();
            que_val.pop();
            if(now->left == nullptr && now->right == nullptr) {
                if(temp == targetSum) return true;
                continue; // 左右结点都是空值，没必要继续遍历下去了
            }
            if(now->left != nullptr) {
                que_node.push(now->left);
                que_val.push(now->left->val + temp);
            }
            if(now->right != nullptr) {
                que_node.push(now->right);
                que_val.push(now->right->val + temp);
            }
        }
        return false;
    }
};
```



**解法二：**DFS

```c++
class Solution {
public:
    // DFS递归法
    bool checkSum(TreeNode* root,int cur, int sum) { // cur记录当前的值
        if(root == NULL)    return false; // 递归边界
        if(root->left == NULL && root->right == NULL) {
            if(cur + root->val == sum)  return true;
            return false;
        }
        return checkSum(root->left, cur + root->val, sum) || checkSum(root->right, cur + root->val, sum);
       }

    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == NULL)    return false;
        return checkSum(root, 0, targetSum);
    }
};
```







#### <a href="https://leetcode-cn.com/problems/path-sum-ii/">路径总和II</a>

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

思路：这道题和上一道题不同之处是不再只是判断是否存在路径总和等于给定数了，还需要我们求出到达

叶子节点的点的路径。

所以我们可以使用数组来存储路径上的点，当符合条件就添加到一个总的数组中去。





解法一：DFS

- 终止条件
  - root==null 
- 递归函数
  - 先判断该点是否是叶子节点，如果是判断到达该节点上的路径总和是否是targetSum，如果是记录该条路径，
  - 如果不是，递归左子树，右子树
  - 递归完左子树和右子树后，说明以该点为分支的树递归完毕，弹出该点root

```c++
class Solution {
public:
    vector<vector<int>> path;
    vector<int> res; // 记录一条路径经过的点
    void dfs(TreeNode* root, int sum, int targetSum) {
        if(root == nullptr) return;
        res.push_back(root->val); // 记录路径上的点
        if(root->left == nullptr && root->right == nullptr) {
            if(sum + root->val == targetSum)    path.push_back(res);
        }
        dfs(root->left, sum + root->val, targetSum);
        dfs(root->right, sum + root->val, targetSum); 
        // 遍历完左边以后，先不急着把root->val弹出，继续遍历右子树，之后再弹出
        res.pop_back(); // 记得弹出，这个点所包含的分支已经遍历过
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root, 0, targetSum);
        return path;
    }
};
```



BFS

BFS用于寻找符合条件的路径，找到符合条件的叶子节点

设计一个函数`getPath()`用来寻找某个叶子节点到达根节点的路径，`unordered_map`存储节点-父节点的映射

```c++
class Solution {
public:
    vector<vector<int>> path;
    unordered_map<TreeNode*, TreeNode*> parent; // 记录一个节点的父节点

    // 将符合条件的路径加入到path中去
    void getPath(TreeNode* root) {
        vector<int> t;
        while(root != nullptr) {
            t.push_back(root->val);
            root = parent[root];
        }
        reverse(t.begin(), t.end());
        path.push_back(t);
    }

    void bfs(TreeNode* root, int targetSum) {
        if(root == nullptr) return;
        queue<TreeNode *> que_node; // 存储遍历的结点
        queue<int> que_val; // 存储遍历的值
        que_node.push(root);
        que_val.push(root->val);
        while(!que_node.empty()) {
            TreeNode* now = que_node.front();
            int temp = que_val.front();
            que_node.pop();
            que_val.pop();
            if(now->left == nullptr && now->right == nullptr)  {
                if(temp == targetSum)   getPath(now);
                continue;
            }
            if(now->left != nullptr) {
                que_node.push(now->left);
                que_val.push(now->left->val + temp);
                parent[now->left] = now; // 记录父节点
            }
            if(now->right != nullptr) {
                que_node.push(now->right);
                que_val.push(now->right->val + temp);
                parent[now->right] = now; // 父节点
            }
        }
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        bfs(root, targetSum);
        return path;
    }
};
```





#### <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树展开单链表</a>

![image-20220123211534180](https://cdn.jsdelivr.net/gh/moon-Light404/my-picGo@master/img/202201232115337.png)



解法一：

1、将左子树插入到右子树的位置

2、将原来的右子树接到左子树的最右边节点

3、考虑新的右子树的根节点，一直重复1、2，直到新的右子树为null

```c++
public:
    void flatten(TreeNode* root) {
       while(root != nullptr) {
           if(root->left == nullptr) {
               root = root->right; // 下个右子树的根节点
           }
           // 存在左子树
           else { 
               // 找到左子树的最右边节点
               TreeNode* Node = root->left;
               while(Node->right != nullptr) {
                   Node = Node->right;
               }
               // 将原来的右子树接到左子树的最右边节点
               Node->right = root->right;
               // 将左子树插入到右子树的位置
               root->right = root->left;
               root->left = nullptr;
               root = root->right; // 遍历下一个右子树的节点
           }
       }
    }
};
```



解法二：

