## 密码脱落(区间DP)

X星球的考古学家发现了一批古代留下来的密码。

这些密码是由A、B、C、D 四种植物的种子串成的序列。

仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。

由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。

你的任务是：

给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。

#### 输入格式

共一行，包含一个由大写字母ABCD构成的字符串，表示现在看到的密码串。

#### 输出格式

输出一个整数，表示至少脱落了多少个种子。

#### 数据范围

输入字符串长度不超过1000

#### 输入样例1：

```
ABCBA
```

#### 输出样例1：

```
0
```

#### 输入样例2：

```
ABDCDCBABC
```

#### 输出样例2：

```
3
```

题意:开始时字符串是回文对称的序列，以后会脱落一些字母形成给出的字符串，题目的意思就是要我们找出最少需要添加多少个字母可以形成回文串。由于字符串左右对称，我们可以先找出==最长的对称子串(可以不连续)==k，然后减去k的长度即为我们要的结果



==区间DP==

顾名思义：区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过**合并小区间的 最优解进而得出整个大区间上最优解的dp算法。**

用`s[L-R]`记录在[L,R]区间上的回文子序列的集合

属性：为最大值

![img](https://cdn.jsdelivr.net/gh/moon-Light404/my_picgo@master/img/20210327184534.jpeg)

`f[L,R-1]`和`f[L+1,R]`会重复计算，但是这里计算的不是数量而是长度的最大值，所以覆盖不会有影响。 下面的包含了上面的 L......

四种子情况分别为 LR 是否包含在回文子序列中，有哪些包含。

循环顺序:

- 循环长度
- 左端点

**状态转移方程**

1、`a[r] = a[l]` ： `f[l][r] = f[l+1][r-1] + 2`

2、`f[l][r] = max(f[i][r-1], f[[i][r], f[i+1][r])` 比较相邻区段的字符串中包含的回文字符串(不需要连续)

```c++
#include<cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int  N = 1100;
char a[N];
int f[N][N]; // f[i][j]表示i到j之间的最大回文子串
int main() {
	cin >> a + 1;
	int maxlen = strlen(a + 1);
	for (int i = 1; i <= maxlen; i++)
		f[i][i] = 1; // 初始化
	for (int len = 1; len < maxlen; len++) { // 长度
		for (int i = 1; i + len <= maxlen; i++ ) { // 起点
			int r = i + len ; // 右端点
			if (a[r] == a[i])
				f[i][r] = f[i + 1][r - 1] + 2;

			f[i][r] = max(f[i][r], f[i][r - 1]);
			f[i][r] = max(f[i][r], f[i + 1][r]);
		}
	}
	cout << maxlen - f[1][maxlen]  << endl;
	return 0;
}
```

